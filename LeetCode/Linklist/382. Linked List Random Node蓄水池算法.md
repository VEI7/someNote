# 382. Linked List Random Node

Given a singly linked list, return a random node's value from the linked list. Each node must have the **same probability** of being chosen.

**Follow up:**
What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space?

**Example:**

```
// Init a singly linked list [1,2,3].
ListNode head = new ListNode(1);
head.next = new ListNode(2);
head.next.next = new ListNode(3);
Solution solution = new Solution(head);

// getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning.
solution.getRandom();
```

### Solution

é‡‡æ ·é—®é¢˜ç»å¸¸ä¼šè¢«é‡åˆ°ï¼Œæ¯”å¦‚ï¼š

1. ä»Ž 100000 ä»½è°ƒæŸ¥æŠ¥å‘Šä¸­æŠ½å– 1000 ä»½è¿›è¡Œç»Ÿè®¡ã€‚
2. ä»Žä¸€æœ¬å¾ˆåŽšçš„ç”µè¯ç°¿ä¸­æŠ½å– 1000 äººè¿›è¡Œå§“æ°ç»Ÿè®¡ã€‚
3. ä»Ž Google æœç´¢ "Ken Thompson"ï¼Œä»Žä¸­æŠ½å– 100 ä¸ªç»“æžœæŸ¥çœ‹å“ªäº›æ˜¯ä»Šå¹´çš„ã€‚

è¿™äº›éƒ½æ˜¯å¾ˆåŸºæœ¬çš„é‡‡ç”¨é—®é¢˜ã€‚

æ—¢ç„¶è¯´åˆ°é‡‡æ ·é—®é¢˜ï¼Œæœ€é‡è¦çš„å°±æ˜¯åšåˆ°å…¬å¹³ï¼Œä¹Ÿå°±æ˜¯ä¿è¯æ¯ä¸ªå…ƒç´ è¢«é‡‡æ ·åˆ°çš„æ¦‚çŽ‡æ˜¯ç›¸åŒçš„ã€‚æ‰€ä»¥å¯ä»¥æƒ³åˆ°è¦æƒ³å®žçŽ°è¿™æ ·çš„ç®—æ³•ï¼Œå°±éœ€è¦æŽ·éª°å­ï¼Œä¹Ÿå°±æ˜¯éšæœºæ•°ç®—æ³•ã€‚ï¼ˆè¿™é‡Œå°±ä¸å…·ä½“è®¨è®ºéšæœºæ•°ç®—æ³•äº†ï¼Œå‡å®šæˆ‘ä»¬æœ‰äº†ä¸€å¥—å¾ˆæˆç†Ÿçš„éšæœºæ•°ç®—æ³•äº†ï¼‰

å¯¹äºŽç¬¬ä¸€ä¸ªé—®é¢˜ï¼Œè¿˜æ˜¯æ¯”è¾ƒç®€å•ï¼Œé€šè¿‡ç®—æ³•ç”Ÿæˆ [0,100000âˆ’1)[0,100000âˆ’1) é—´çš„éšæœºæ•° 1000 ä¸ªï¼Œå¹¶ä¸”ä¿è¯ä¸é‡å¤å³å¯ã€‚å†å–å‡ºå¯¹åº”çš„å…ƒç´ å³å¯ã€‚

ä½†æ˜¯å¯¹äºŽç¬¬äºŒå’Œç¬¬ä¸‰ä¸ªé—®é¢˜ï¼Œå°±æœ‰äº›ä¸åŒäº†ï¼Œ**æˆ‘ä»¬ä¸çŸ¥é“æ•°æ®çš„æ•´ä½“è§„æ¨¡æœ‰å¤šå¤§**ã€‚å¯èƒ½æœ‰äººä¼šæƒ³åˆ°ï¼Œæˆ‘å¯ä»¥å…ˆå¯¹æ•°æ®è¿›è¡Œä¸€æ¬¡éåŽ†ï¼Œè®¡ç®—å‡ºæ•°æ®çš„æ•°é‡ ð‘Nï¼Œç„¶åŽå†æŒ‰ç…§ä¸Šè¿°çš„æ–¹æ³•è¿›è¡Œé‡‡æ ·å³å¯ã€‚è¿™å½“ç„¶å¯ä»¥ï¼Œä½†æ˜¯å¹¶ä¸å¥½ï¼Œæ¯•ç«Ÿè¿™å¯èƒ½éœ€è¦èŠ±ä¸Šå¾ˆå¤šæ—¶é—´ã€‚ä¹Ÿå¯ä»¥å°è¯•ä¼°ç®—æ•°æ®çš„è§„æ¨¡ï¼Œä½†æ˜¯è¿™æ ·å¾—åˆ°çš„é‡‡æ ·æ•°æ®åˆ†å¸ƒå¯èƒ½å¹¶ä¸å¹³å‡ã€‚

ç»ˆäºŽè¦è®²åˆ°è“„æ°´æ± é‡‡æ ·ç®—æ³•ï¼ˆReservoir Samplingï¼‰äº†ã€‚å…ˆè¯´ä¸€ä¸‹ç®—æ³•çš„è¿‡ç¨‹ï¼š

å‡è®¾æ•°æ®åºåˆ—çš„è§„æ¨¡ä¸º ð‘›ï¼Œéœ€è¦é‡‡æ ·çš„æ•°é‡çš„ä¸º ð‘˜ã€‚

é¦–å…ˆæž„å»ºä¸€ä¸ªå¯å®¹çº³ ð‘˜ ä¸ªå…ƒç´ çš„æ•°ç»„ï¼Œå°†åºåˆ—çš„å‰ ð‘˜ ä¸ªå…ƒç´ æ”¾å…¥æ•°ç»„ä¸­ã€‚

ç„¶åŽä»Žç¬¬ ð‘˜+1 ä¸ªå…ƒç´ å¼€å§‹éåŽ†æ•°æ®ï¼ŒéåŽ†ä¸‹æ ‡ä¸ºiï¼Œä»¥ ð‘˜/i çš„æ¦‚çŽ‡æ¥å†³å®šè¯¥å…ƒç´ æ˜¯å¦è¢«æ›¿æ¢åˆ°æ•°ç»„ä¸­ï¼ˆæ•°ç»„ä¸­çš„å…ƒç´ è¢«æ›¿æ¢çš„æ¦‚çŽ‡æ˜¯ç›¸åŒçš„ï¼‰ã€‚ å½“éåŽ†å®Œæ‰€æœ‰å…ƒç´ ä¹‹åŽï¼Œæ•°ç»„ä¸­å‰©ä¸‹çš„å…ƒç´ å³ä¸ºæ‰€éœ€é‡‡å–çš„æ ·æœ¬ã€‚

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    /** @param head The linked list's head.
        Note that the head is guaranteed to be not null, so it contains at least one node. */
    Solution(ListNode* head) {
        this->head = head;
    }
    
    /** Returns a random node's value. */
    int getRandom() {
        ListNode* node = head;
        int res = node->val;
        int idx = 2;
        while(node->next!=NULL)
        {
            node = node->next;
            if(rand()%(idx) == 0)
                res = node->val;
            idx++;
        }
        return res;
    }
    
private:
    ListNode *head;
};

/**
 * Your Solution object will be instantiated and called as such:
 * Solution* obj = new Solution(head);
 * int param_1 = obj->getRandom();
 */
```



## 528. Random Pick with Weight

Given an array `w` of positive integers, where `w[i]` describes the weight of index `i`, write a function `pickIndex` which randomly picks an index in proportion to its weight.

Note:

1. `1 <= w.length <= 10000`
2. `1 <= w[i] <= 10^5`
3. `pickIndex` will be called at most `10000` times.

**Example 1:**

```
Input: 
["Solution","pickIndex"]
[[[1]],[]]
Output: [null,0]
```

**Example 2:**

```
Input: 
["Solution","pickIndex","pickIndex","pickIndex","pickIndex","pickIndex"]
[[[1,3]],[],[],[],[],[]]
Output: [null,0,1,1,1,0]
```

**Explanation of Input Syntax:**

The input is two lists: the subroutines called and their arguments. `Solution`'s constructor has one argument, the array `w`. `pickIndex` has no arguments. Arguments are always wrapped with a list, even if there aren't any.

### Solution

```c++
class Solution {
public:
    Solution(vector<int>& w) {
        w_sum.push_back(w[0]);
        for(int i=1; i<w.size(); i++)
        {
            w_sum.push_back(w_sum[i-1]+w[i]);
        }
        
    }
    
    int pickIndex() {
        int t = rand() % w_sum.back();
        int start = 0, end = w_sum.size()-1;
        while(start<end)
        {
            int mid = (start+end)/2;
            if(t>=w_sum[mid])
            {
                start = mid+1;
            }
            else
                end = mid;
        }
        return end;
    }
private:
   vector<int> w_sum; 
};

/**
 * Your Solution object will be instantiated and called as such:
 * Solution* obj = new Solution(w);
 * int param_1 = obj->pickIndex();
 */
```

```c++
class Solution {
public:
    Solution(vector<int>& w) {
        w_sum.push_back(w[0]);
        for(int i=1; i<w.size(); i++)
        {
            w_sum.push_back(w_sum[i-1]+w[i]);
        }  
    }
    
    int pickIndex() {
        int t = rand() % w_sum.back();
        return upper_bound(w_sum.begin(), w_sum.end(), t) - w_sum.begin();
    }
private:
   vector<int> w_sum; 
};

/**
 * Your Solution object will be instantiated and called as such:
 * Solution* obj = new Solution(w);
 * int param_1 = obj->pickIndex();
 */
```

## 710. Random Pick with Blacklist 

Given a blacklist `B` containing unique integers from `[0, N)`, write a function to return a uniform random integer from `[0, N)` which is **NOT** in `B`.

Optimize it such that it minimizes the call to systemâ€™s `Math.random()`.

**Note:**

1. `1 <= N <= 1000000000`
2. `0 <= B.length < min(100000, N)`
3. `[0, N)` does NOT include N. See [interval notation](https://en.wikipedia.org/wiki/Interval_(mathematics)).

**Example 1:**

```
Input: 
["Solution","pick","pick","pick"]
[[1,[]],[],[],[]]
Output: [null,0,0,0]
```

**Example 2:**

```
Input: 
["Solution","pick","pick","pick"]
[[2,[]],[],[],[]]
Output: [null,1,1,1]
```

**Example 3:**

```
Input: 
["Solution","pick","pick","pick"]
[[3,[1]],[],[],[]]
Output: [null,0,0,2]
```

**Example 4:**

```
Input: 
["Solution","pick","pick","pick"]
[[4,[2]],[],[],[]]
Output: [null,1,3,1]
```

**Explanation of Input Syntax:**

The input is two lists: the subroutines called and their arguments. `Solution`'s constructor has two arguments, `N` and the blacklist `B`. `pick` has no arguments. Arguments are always wrapped with a list, even if there aren't any.



### Solution

```c++
class Solution {
public:
    Solution(int N, vector<int>& blacklist){
        unordered_set<int> st;
        len = N-blacklist.size();
        for(int i=len; i<N; i++) st.insert(i);
        for(auto num : blacklist) st.erase(num);
        auto it = st.begin();
        for(auto num : blacklist)
        {
            if(num<len) m[num] = *it++;
        }
    }
    
    int pick() {
        int x = rand()%len;
        if(m.find(x) != m.end()) return m[x];
        return x;
    }
private: 
    unordered_map<int, int> m;
    int len;
};

/**
 * Your Solution object will be instantiated and called as such:
 * Solution* obj = new Solution(N, blacklist);
 * int param_1 = obj->pick();
 */
```

